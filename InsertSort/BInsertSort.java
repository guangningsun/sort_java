/**
 * 折半插入排序
 * 将直接插入排序中寻找A[i]的插入位置的方法改为采用折半比较
 * 1、同样认为第一位是有序的，从第二位开始遍历整个数组
 * 2、如果无序队列第一个值小于或大于有序队列的最后一个值，则进行插入排序
 * 3、声明哨兵，折半插入要扫描的左边界和有边界，并将无序队列的第一位值赋给哨兵
 * 4、当扫描边界左侧小于右侧时，通过折半查找来找到 哨兵要插入的位置
 * 5、查找的最终为low为哨兵要插入的位置，将从low到有序区末尾的值整体后移
 * 6、将哨兵插入low的位置，结束本次插入
 * 
 * 空间复杂度为O(1)   附加空间仍然是1
 * 时间复杂度为O(n^2) 与直接插入相比折半查找只是减少了比较次数，但是元素的移动次数不变
 * 
 * */

public class BInsertSort {
	public int[] bInsertSort(int a[]){
		for(int i=1;i<a.length;i++){//同样认为第一个是有序的
			if(a[i]<a[i-1]){ //如果无序队列第一个值小于或大于有序队列的最后一个值，则进行插入排序
				int sentinel; //声明哨兵
				int low = 0;// 定义扫描边缘左边界
				int high = i - 1;//定义扫描边缘右边界
				sentinel = a[i];//给哨兵赋值
				while (low <= high) {
					int mid = (low + high) / 2;
					if (a[mid] > sentinel) {
						high = mid-1;
					} else {
						low = mid+1;
					}
				}
				//low 到i处数据整体后移一位
				for (int j = i; j > low; j--) {
					a[j] = a[j - 1];
				}
				//将哨兵的值赋给空出来的位置
				a[low] = sentinel;
			}
			}
		return a;
	}
}
